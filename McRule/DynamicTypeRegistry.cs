
using System.Linq.Dynamic.Core;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;

public class DynamicTypeRegistry
{
    /// <summary>
    /// This method builds a dynamic selector (Func<T,T>) expression for type T that copies only the specified properties
    /// from a given source record. Similar to this Linq expression:
    /// .Select(x => new T { Prop1 = x.Prop1, Prop2 = x.Prop2, ... })
    ///
    /// In fact, a ToString() of an expression generated by this method will look very similar:
    /// x => new User() {First = x.First, Last = x.Last, Mail = x.Mail, Tenure = x.Tenure}
    ///
    /// For non-specified propterties, they will be set to the default for the class. Any default
    /// values specified in the constructor or property definitions will be used.
    /// </summary>
    public static Expression<Func<T, T>> DynamicSelector<T>(params string[] properties)
    {
        return DynamicSelector<T>(properties, false);
    }

    /// <summary>
    /// This method builds a dynamic selector (Func<T,T>) expression for type T that copies only the specified properties
	/// from a given source record. Similar to this Linq expression:
	/// .Select(x => new T { Prop1 = x.Prop1, Prop2 = x.Prop2, ... })
	///
	/// In fact, a ToString() of an expression generated by this method will look very similar:
	/// x => new User() {First = x.First, Last = x.Last, Mail = x.Mail, Tenure = x.Tenure}
	///
	/// For non-specified propterties, they will be set to the default for the class. Any default
	/// values specified in the constructor or property definitions will be used.
	///
	/// Note, this fails for types which don't have a default constructor. This includes 'record' types as of C# 9.0.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="properties"></param>
    /// <param name="usePropertyTypeDefaults">
	/// If set to true, non specified properties will initialize to the default() value for their type.
	/// Otherwise, they will inherit any defaults specified in the class definition or constructor.
	/// </param>
    /// <returns></returns>
    public static Expression<Func<T, T>> DynamicSelector<T>(string[] properties, bool usePropertyTypeDefaults = false)
    {
        var param = Expression.Parameter(typeof(T), "x");
        var constructor = Expression.New(typeof(T));

        // property initializers from list of property names
        var bindings = properties.Select(p => p.Trim())
            .Select(x => {
                var sourceProp = typeof(T).GetProperty(x);
                if (sourceProp == null) return null;

                var sourceValue = Expression.Property(param, sourceProp);
                return Expression.Bind(sourceProp, sourceValue);
            }
        ).Where(x => x != null);

        // if usePropertyTypeDefaults is true, set all other properties to default value
        if (usePropertyTypeDefaults)
        {
            var otherBindings = typeof(T).GetProperties()
                .Where(p => !properties.Contains(p.Name))
                .Select(p => Expression.Bind(p, Expression.Default(p.PropertyType)));
            bindings = bindings.Concat(otherBindings);
        }

        var initializedObject = Expression.MemberInit(constructor, bindings);
        var lambda = Expression.Lambda<Func<T, T>>(initializedObject, param);
        return lambda;
    }

    /// <summary>
    /// This method builds an anonymous type selector (Func<T,object>) expression for type T
	/// that can be used to select a subset of properties from T into an anonymous type.
	/// The expression is exactly the same as this Linq expression:
	/// x => new { Prop1 = x.Prop1, Prop2 = x.Prop2, ... }
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="properties">List of property names.</param>
    /// <returns>Expression</returns>
    /// <exception cref="Exception">Property name matches are case sensitive. An exception is thrown if no matches are found.</exception>
    public static Expression<Func<T, object>> BuildAnonymousSelector<T>(params string[] properties)
    {
        var param = Expression.Parameter(typeof(T), "x");

        // property initializers from list of property names
        var dynamicProps = properties.Select(p => p.Trim())
            .Select(x => {
                var sourceProp = typeof(T).GetProperty(x);
                if (sourceProp == null) return null;

                return new DynamicProperty(sourceProp.Name, sourceProp.PropertyType);
            }).Where(x => x != null)
            ?.ToList();

		if (dynamicProps == null || dynamicProps.Count == 0) {
			throw new Exception($"No valid properties were specified to build the anonymous type. Supplied properties: {String.Join(", ", properties)}");
        }

        var returnType = DynamicClassFactory.CreateType(dynamicProps, false);
        var constructor = Expression.New(returnType);

        var bindings = dynamicProps.Select(p => Expression.Bind(returnType.GetProperty(p.Name), Expression.Property(param, p.Name)));
        var initializedObject = Expression.MemberInit(constructor, bindings);
        var lambda = Expression.Lambda<Func<T, object>>(initializedObject, param);
        return lambda;
    }

    /// <summary>
    /// This method builds a transmutation selector (Func<T1,T2>) expression that copies all
	/// properties with matching names from T1 to T2. The resulting expression can be compiled
	/// and used inside of a Linq Select() call to convert from one type to another.
    /// </summary>
    /// <typeparam name="T1"></typeparam>
    /// <typeparam name="T2"></typeparam>
    /// <returns></returns>
    public static Expression<Func<T1, T2>> Transmute<T1, T2>()
    {
        var param = Expression.Parameter(typeof(T1), "x");

        var returnType = typeof(T2);
        var constructor = Expression.New(returnType);

        // property initializers from list of property names
        var sourceProps = typeof(T1).GetProperties()
            .Select(x => {
				var sourceProp = x;

                return new DynamicProperty(sourceProp.Name, sourceProp.PropertyType);
            }).Where(x => returnType.GetProperty(x.Name) != null)
            .ToList();

        var bindings = sourceProps.Select(p => Expression.Bind(returnType.GetProperty(p.Name), Expression.Property(param, p.Name)));
        var initializedObject = Expression.MemberInit(constructor, bindings);
        var lambda = Expression.Lambda<Func<T1, T2>>(initializedObject, param);
        return lambda;
    }


    protected class McDynamicType {
		public string name { get; set;}
		public TypeBuilder tb {get; set;}
		Type _builtType;
		public Type builtType
		{
			get {
				if (_builtType == null) { _builtType = tb.CreateType(); }
				return _builtType;
			}
		}
		public string[] properties {get; set;}

		public Type buildForType {get; set;}

		public Func<T,T> GetDynamicSelector<T>() {
			return DynamicSelector<T>(properties).Compile();
		}
	}

	AssemblyBuilder dynAsm { get; set; }
	ModuleBuilder dynModule { get; set; }

	Dictionary<string, McDynamicType> registeredTypes = new Dictionary<string, McDynamicType>();


	public DynamicTypeRegistry()
	{
		dynAsm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("McDynamicAssembly"), AssemblyBuilderAccess.Run);
		dynModule = dynAsm.DefineDynamicModule("McTypes");
	}

	public Func<T, T> DynamicSelector<T>(string dynName)
	{
		McDynamicType dynType = null;
		var sourceType = typeof(T);

		if (registeredTypes.TryGetValue(dynName, out dynType))
		{
			return dynType.GetDynamicSelector<T>();
		}
		return null;
	}

	public dynamic CopyFromSourceObject<T>(T source, string dynName)
	{
		McDynamicType dynType = null;
		var sourceType = typeof(T);

		if (registeredTypes.TryGetValue(dynName, out dynType))
		{
			var resultType = dynType.builtType;
			var result = dynAsm.CreateInstance(dynType.name);

			foreach (var p in dynType.properties) {
				var prop = resultType.GetProperty(p);
				prop.SetValue(result, sourceType.GetProperty(p).GetValue(source));
			}
			return result;
		}
		return null;
	}

	public void BuildDynamicSubType<T>(string shortName, IEnumerable<string> properties)
	{
		var requestedType = typeof(T);
		var props = properties.ToArray();
		Array.Sort(props);
		var dynTypeName = shortName ?? $"{requestedType.Name}_{String.Join('-',props)}"; // TODO make this a concatination of the policy ids for a given predicate and type.
		var dynType = dynModule.DefineType(dynTypeName);

		foreach (var p in properties)
		{
			var reflectedProperty = requestedType.GetProperty(p);

			if (reflectedProperty == null) continue;

			AddProperty(dynType, p, reflectedProperty.PropertyType);
		}

		var builtType = new McDynamicType();
		builtType.tb = dynType;
		builtType.buildForType = typeof(T);
		builtType.name = dynTypeName;
		builtType.properties = props;

		registeredTypes.Add(dynTypeName, builtType);
	}

	public Type GetDynamicObjectByTypeName(string Name)
	{
		McDynamicType result = null;
		if (registeredTypes.TryGetValue(Name, out result))
		{
			return result.builtType;
		}
		return typeof(Object);
	}

	private void AddProperty(TypeBuilder typeBuilder, string propertyName, Type propertyType)
	{
		const MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.HideBySig;

		// Backing field
		FieldBuilder field = typeBuilder.DefineField("_" + propertyName, typeof(string), FieldAttributes.Private);
		PropertyBuilder property = typeBuilder.DefineProperty(propertyName, PropertyAttributes.None, propertyType,
			new[] { propertyType });

		// Getter
		MethodBuilder getMethodBuilder = typeBuilder.DefineMethod("get_value", getSetAttr, propertyType,
			Type.EmptyTypes);
		ILGenerator getIl = getMethodBuilder.GetILGenerator();
		getIl.Emit(OpCodes.Ldarg_0);
		getIl.Emit(OpCodes.Ldfld, field);
		getIl.Emit(OpCodes.Ret);

		// Setter
		MethodBuilder setMethodBuilder = typeBuilder.DefineMethod("set_value", getSetAttr, null,
			new[] { propertyType });
		ILGenerator setIl = setMethodBuilder.GetILGenerator();
		setIl.Emit(OpCodes.Ldarg_0);
		setIl.Emit(OpCodes.Ldarg_1);
		setIl.Emit(OpCodes.Stfld, field);
		setIl.Emit(OpCodes.Ret);

		property.SetGetMethod(getMethodBuilder);
		property.SetSetMethod(setMethodBuilder);
	}
}
